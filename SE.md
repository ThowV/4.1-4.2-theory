# Software Engineering

Software Engineering is the application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software; that is, the application of engineering to software. (IEEE)

Simply put: The purpose of software engineering is to find ways of building quality software.

## 1. The software process model definition

To develop software we often use a software process model, aka a software life-cycle model. These mdels consist of a sequence of decisions:

- The activities;
- The order;
- The transition criteria;

### 1.1 Deciding factors on the choice of model

To decide which model to use there are a few criteria to keep in mind:

- The quality of requirements: A fixed **scope** is only possible with a clear set of requirements. If there are sudden changes and the **requirements** change it means the **scope** isn't fixed;
- Domain complexity: Is the company environment complex? If so it results in extra conditions being applied to the **scope**;
- Is the technology proven and/or complex? If it's complex it's difficult to set a fixed **scope**.
- Flexibility: Is flexibility important? Do we expect **requirements** to change? If so we again can't sit a fixed **scope**;
- Project size: When we have a small project it's easy to set a fixed **scope**, for a large project it isn't;
- Criticality: Criticality pertains to the compliance, medical or safety critical systems. If the criticality is high we need to have a fixed **scope**;
- Stakeholder involvement: Stakeholders might have their say in the definition of **requirements**;
- Team skills: Insight into the skills of the team is a necessity when defining the **requirements**. Are we capable of implementing the **requirements**;

### 1.2 The iron triangle

The key defining factors from above can be boiled down to the following three keywords:

- Scope
- Resources
- Time

The iron triangle helps decide which software process model to use:

- Waterfall: **Scope** is fixed but **time** and **resources** may vary.
- Iterative: **time** and **resources** are fixed but **scope** may vary.

## 2. Software process model: Waterfall

The Waterfall software process model takes a phase-by-phase approach where we (in order): Plan, build, test, review and deploy. In this approach the requirements are fixed as early as possible, as after the build process you cannot change the requirements any longer.

### 2.1 Waterfall problems

The Waterfall framework has a few problems:

- There's great difficulty in handling changing requirements, changes will be limited so this model should only be used when the requirements are well understood and the **scope** is fixed;
- It's difficult to handle technical risks;
- Customer feedback comes at the end which means you might end up with a product that doesn't satisfy customers;
- Mostly used for large projects where a system is developed at several locations:
	+ A lot of documentation with a lot of roles;
	+ The plan-driven nature of the Waterfall model helps co√∂rdinate the work;
	+ Useful for systems where compliance is key.

## 3. Software process model: Iterative

The Iterative software process model repeats the same development steps over and over until you reach the desired result where all requested functionality is covered.
In this process we:

- Plan and Evaluate;
- Gather requirements;
- Design and implement;
- Verify;

This way you can start with a small piece of functionality and iterate on it, even if the requirements changes without any issue.

### 3.1. RUP framework

- UP stands for Unified Software Development Process which is an iterative and incremental framework;
- RUP is an elaboration of UP which is owned by IBM;
- OpenUP, Open Unified Process, is an open-source framework maintained by the Eclipse Foundation;
- RUP-Op-Maat is an elaboration of RUP and is owned by Ordina;

RUP has four phases:

- The inception phase **(incremental)**:
	+ Scope all the work, initial budget estimates are made;
	+ Align visions;
	+ Identify risks and global planning;
	+ Define acceptance criteria which are testable;
	+ Produces the following artifacts:
		* Vision;
		* Risk list;
		* Use Case Model;
		* Acceptance Plan;
		* Global Software Development Plan (SDP);
- The elaboration phase **(incremental)**:
	+ Prove the technical feasibility and validate the architecture;
	+ Create a design/proof-of-concept;
	+ Produces the following artifacts:
		* PoC;
		* Complete Software Development Plan (SDP);
		* SAD;
		* Test plan;
		* Development and testing environment;
- The construction phase **(iterative)**:
	+ Focus on implementation;
	+ Do this in iterations/sprints;
- The transition phase **(incremental)**:
	+ Focus on the deployment;
	+ Hand the product over to maintenance;
	
### 3.2 Agile framework 

Agile development has analysis, design, implementation and testing in every iteration/sprint as opposed to RUP. Every sprint delivers a small product.

Agile uses a conversational approach where requirements are continuously negotiated during development. This way, risks or changes are identified at the start of a sprint which makes their impact minimal.

#### 3.2.1 Agile problems

Agile is good in many ways but has a few problems:

- Difficult to plan the amount of iterations needed;
- Only works for smaller teams;
- Requires skilled people as every team member has many roles;
- Development is intense as the need to complete each feature within the corresponding iteration is pressuring;
- Active client/user involvement is required which means they need to be available during the project and which means the developers must comply and adapt to a change of culture;
- Risks lie with the customers as a fixed price tender is not possible;
- Product owner must manage the interests of the different stakeholders as they'll be tempted to keep demanding new functionality;
- Quality might lack as the product is a moving target with a 'code and fix' approach;
- Less documentation as 'the code' = 'the design'. This results in a slow start for newcomers, inefficient maintenance when there's a problem and a loss of the big picture;